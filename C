读《C和指针》有感
关于c的一些零碎知识
0.	用到“指针”时一定要思考一些问题
{
1．	它指向谁！
2．	能不能访问！
3．	是否会导致内存泄漏！
}
1.C  = 声明 + 函数
  声明：描述函数和函数将要操作的数据类型
  函数：定义了需要执行的工作
2.C 中大小写敏感
3.标识符 ：变量，函数，类型的名字
           由“字母，数字，下划线”组成，不以数字开头
          关键字不能作为标识符使用
4.
用if，for在括号和表达式之间留空格，使表达式更突出
嵌套语句学会用Tab键缩进
不应该嵌套注释
5.
缺省：系统默认状态
字面值：指在程序中无需变量保存，可直接表示为一个具体的数字或字符串的值（常量）
6.
浮点数字面值总是写成十进制形式，它必须有一个小数点或一个指数或者两者都有
例：3,14159，1E10, 25., .5 ，6.023e23
浮点数字面值缺省下都是double型除非后面跟
L或l 表示 long double
F或f 表示 float

7.字符串常量与指针
使用字符串常量会生成一个“指向字符的常量指针”（字符的位置被固定）所以使用字符串常量时，所使用的值是这些字符所有存储的地址，而非字符本身，因此，你可以吧字符串常量赋值给一个“指向字符的指针”后置指向这些字符所存储的地址但你不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是指针，而不是这些字符本身
所以想要赋值一个字符串最好使用数组
8.
下面两个声明的效果相同
unsigned short int a；
unsigned short a；
9.
typedef（用于给数据类型定义新的名字）
typedef char *pointer；
pointer a； 声明了a是一个指向char类型的指针
10.指针与常量
（不可修改指针值是指不可改变指针所指向的地址）
（1）int *pi 
pi是一个普通的指向整型的指针，既可修改指针的值也可修改它所指向的值
（2）int const *pci（指针常量）
pci是一个指向整型常量的指针，不可通过指针修改它所指向的值，但可以修改指针的值
其中的 int *str[]=“Hello”，str就是一个指针常量，所以企图通过指针去修改str的值是错误的
（3）int * const ci （常量指针）
ci是一个指向整型的常量指针，可以通过指针修改它所指向的值，但不可修改指针的值
例：int a，b；
Int *const i=&a；
I = &b（错误）
（4）int const *const pi
Pi是一个指向整型常量的指针常量, 既不可修改指针的值也不可修改它所指向的值 
 11.
（1）在if语句中最好加括号
（2）每个switch都使用default字句
（3）在一个没有循环体的循环中最后用一个分号表示空语句并让它独占一行
   例： for（；；）
           ；

12.移位操作符 （<< ,>>）
左移：
                        移位前
（丢弃）0 1 1            移位后
                         最终结果

右移：
（1）	逻辑移位：缺的部分用0填充
（2）	算术移位：移入的位由原先该值的符号为决定
                 符号位为1 则用1填充
                 符号位为0 则用0填充
例： 10010110右移两位
逻辑移位：00100101
算术移位：11100101
只有在负值时，左移和右移才有所不同

13．
判断表达式的长度并不需要对表达式进行赋值
所以sizeof（a=b+1）并未对a进行赋值

14.左值与右值
左值：能够出现在赋值符号“=”左边的东西（通常是标识了一个可以存储结果值的地点即地址）        
右值：能够出现在赋值符号“=”右边的东西（通常是一个指定的值）
a=b+25（a为左值，b+25为右值）
b+25 = a（因为b+25并未标识一个特定的位置即你不清楚它到底存储在哪个地方，无法预测所以是违法操作）
字面值(常量)也不可当左值

15.
（1）NULL指针就是不指向任何东西的指针，它可以赋值给一个指针，用于表示那个指针并不指向任何值。
（2）在指针值上可以执行一些有限的算术运算。可以把一个整型值加到一个指针上，也可以从一个指针减去一个整型值。两种情况下，这个整型值会进行调整，原值将乘以指针目标类型的长度，这样对一个指针加1将使她指向下一个变量
（3）指针运算只有作用于数组中其结果才是可以预测的。对任何并非指向数组元素的指针执行算术运算是非法的，如果一个指针减去一个整数后，运算结果产生的指针所指向的位置在数组第一个元素之前，那么它也是非法的。如果加上一个数结果指针指向数组最后一个元素后面的那个内存位置仍是合法的（但你不能对这个指针执行间接访问）
（4）如果两个指针都指向同一个数组中的元素，那么它们之间可以相减，其结果是标识两个指针在数组中相隔多少个元素

16．
（1）	数组名的值是一个指针常量，也就是数组第一个元素的地址
（2）	以下两种情况数组名并不用指针常量来表示
（i）	数组名作为sizeof操作符：sizeof返回整个数组的长度，而不是指向数组的指针的长度
（ii）	作为单目操作符&：取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量值的指针
17．
声明一个数组时，编译器将根据声明所指定的元素数量为数组保留内存空间，然后在创建数组名，它的值是一个常量，指向这段空间的起始位置。
声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何整型值分配内存空间。而且，指针变量并未被初始化为指向任何现有的内存空间
int a[5]；int *b； *a是完全合法的，而表达式*b是非法的，*b将访问内存中某个不确定的位置，另外b++可以通过编译而a++不能，因为a的值是个常量。
18.
字符数组的初始化
char message1[]=“hello”；
char  *message2=“hello”；（指针常量）
这两个初始化看上去很像，但它们具有不同的含义。前者初始化一个字符数组元素，而后者则是一个真正的字符串常量。这个指针变量被初始化为了指向这个字符串常量的存储位置。

19.多维数组
一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第一个元素。
多维数组也差不多，唯一的区别是多维数组第一维的元素实际上是另一个数组
例：
int a[3][10];
创建了a，它可以看做是一个一维数组，包含3个元素，只是每个元素恰好是包含10个整型元素的数组
A这个名字的值是一个指向它第一个元素的指针所以a是一个指向一个包含10个整型元素的数组指针
20.
int a[10], *p=a;
int aa[3][10],*pp=aa;
第一个声明是合法的，它为一个整型数组分配内存，并把p声明为一个指向整型的指针，并把它初始化为指向a数组的第一个元素。a和p具有相同的类型：“指向整型的指针”。
但是第二个声明是不合法的，它正确创建了aa数组，并把pp声明为一个指向整型的指针。但是，pp的是初始化是不正确的，因为aa不是一个指向整型的指针，而是一个指向整型数组的指针。
因此应该这么声明；int （*pp）[10]=aa;
当这样声明是其访问的方式和aa访问的方式就无异了
1.aa+1与pp+1同为表示“指向包含10个整型元素的数组的指针”，它指向aa的另一行死
2.*(aa+1)与*(pp+1)事实上标识了一个包含10个整型元素的子数组。数组名的值是个常量指针，它指向数组的第一个元素，这个表达式也是如此，也就是下一行的首地址。
3.*（aa+1）+5 与*（pp+1）+5 它指向的位置比上一个那个表达式所指向的位置后移动了5个整型元素。
4. *(*（aa+1）+5)与*(*（pp+1）+5)表示的都是访问此时第5个整型元素的值 

21.结构
1.结构变量属于标量类型，它可以作为传递给函数的参数，也可以作为返回值从函数返回，相同类型的结构变量相互之间可以赋值，也可以声明指向结构的指针，声明结构数组。
2.结构的声明
（i）格式：struct tag（标签） {member-list} variable-list
  struct {
         int a;	
			 char b;
			 float z;
} y[20],*z;
这个声明创建了y和z。y是个数组，它包含了20个数组。Z是一个指针，它指向这个类型的结构
也可以这样
  struct  SIMPLE{
         int a;	
			 char b;
			 float z;
} y[20],*z;
 这个声明将标签SIMPLE和这个成员列表联系一起了，但他并未设置变量但通过标签以后定义变量就可以这样
SIMPLE y[20],*z;这样和上述第一个例子定义是一样的
还有一个定义技巧（推荐！！）
typedef struct {
 				int a;
           int b[20];
}simple;
它和声明一个结果标签的效果一样，只不过在于simple是个类型名而不是标签
后面的定义也就可以这样
Simple x；simple y[20],*z;
 ii). 结构成员，可以是标量、数组、指针、甚至是其他结构
	例： struct CMOPLEX{
 					int a[20];
 					float f;
 					long *lp;
 					struct SIMPLE s;	
};
	一个结构的成员名字可以和其他结构的名字相同不会冲突
iii). 结构成员的直接访问
结构变量的成员是通过“点操作符”(.)访问的。
例：struct COMPLEX comp；
	 comp.a就选择了这个成员。这个表达式的结果是个数组
例：成员sa是个结构数组，所以comp.sa是一个数组名，它的值本身是一个指针常量，如（comp.sa）[4]将选择一个数组元素。但这个元素本身是一个结构，所以可以采用以下方式
((comp.sa)[4]).c 由于下标引用和点操作符具有相同的优先级，且结合行都是从左向右，所以可以省略括号变成
comp.sa[4].c
iiii)结构成员的间接访问
如果有一个指向结构的指针应该使用“箭头操作符”（->）来进行间接的访问
例:有个指向struct COMPLEX 的指针cp
则 cp->a,cp->s表示第一个访问的是结构中的数组a，第二个访问的是结构中的结构s
iiiii)结构的自引用
struct SEL-REF1{
		int a；
		struct SEL-REF1 b；
}；
struct SEL-REF2{
int a；
struct SEL-REF2 *b
}
第一个自引用是错误的，死循环了
第二个才是正确的，b现在是一个指针而非结构
需注意
typedef struct {
       int a;
       SELF-REF3 *b
}SELF-REF3;
typedef struct SELF-REF3{
       int a;
       SELF-REF3 *b
}SELF-REF3;
第一个声明错误，因为类型名直到声明的末尾才定义，导致结构声明的内部它没有定义
第二个定义才是正确的
（iiiiii）访问结构成员
有四种情形
1.	访问结构体中的成员
typedef struct {
	int a;
	short b[2];
}xx;
typedef struct y {
	int a1;
	char b1[3];
	xx   c;
	struct y *d;
}yy;

/*
** 定义了两个结构体
*/


int main(){
	yy  i ={10,"hi",{5,{-1,25}},0}; //定义了结构体变量i以及进行了初始化
	yy *p = &i;   //定义了yy结构体类型的指针并指向i（i与p是同一数据类型）
	printf("%d",p->a1); //间接访问了i中的结构体成员
     printf(“%d”,i.a1); //直接访问（不推荐因为你需要知道结构成员的名字）

其中：*p与p->a1 他们两个所保存的地址是一样的但是尽管如此因为他们的类型不同p是被声明为一个指向结构的指针。所以表达式*p的结果是整个结构。而非第一个成员 ，还有表达式p->b的值是一个指针常量，因为b是一个数组，不能当左值也就是不能修改但也可以访问如
p->b[1]如此…
2.	访问嵌套的结构
typedef struct {
	int a;
	int b[3];

}xx;


typedef struct y1{
	int a1;
	char b[3];
	xx c;
	struct y1 *d;
	
}yy;

int main(){
	yy i = {5,"hi",{5,{3,4,6}},0};
	yy *p = &i; 
	printf("%d",p->c.a);//利用指针访问结构体中结构体中的成员
	printf("%d",*p->c.b);//访问结构体i中的结构体c中的b数组并进行解引用
其中：*p->c.b 有三个操作符，首先执行箭头 p->c结果是结构增加.b的操作访问c的成员b，b是一个数组p->c.b结果是一个常量指针，指向第一个元素，最后进行解引用
}
3.	访问指针成员
typedef struct {
	int a;
	int b[3];

}xx;


typedef struct y1{
	int a1;
	char b[3];
	xx c;
	struct y1 *d;
	
}yy;

int main(){
	yy i = {5,"hi",{5,{3,4,6}},0};
	yy r;//定义了yy结构体类型的变量r
	i.d =&r;//取i中的指针d并取r的地址赋值给i.d
	yy *p = &i; 
	printf("%d",p->d->c.a);//连环的箭头操作指针指向指针中的结构的成员，但这有错因为d指向的结构并未初始化
	printf("%d",p->d->a1);//同上
其中：*p->d是错误的因为d是指针且被赋值为0（其实就是NULL）对NULL进行解引用是不行的

}
iiiiiii)结构体可以作为参数传递给函数，也可以作为返回值从函数返回，使用指针传递效率更高
        在结构指针参数的声明中可以加上const关键字防止函数修改指针所指向的结构
22.关于位段
位段相当于自己创立一个变量自己定义它占多少字节也就是指定它占多少位
其定义的方式和定义结构体类似,只有两个不同
1.位段的成员必须声明为int,unsigned int ,signed int 类型
2.在成员名的后面是一个冒号和一个整数,这个整数指定该位段占用位的数目
比如定义一个文本格式化程序
struct CHAR {
	unsigned ch   :  7;
	unsigned font :  6;
	unsigned size :  19;
};
struct CHAR ch1;
:暂时不知道有什么用

23.联合
	1.联合的使用方式和结构体类似只需将struct改成union即可,但二者却有很大的不同
 	  联合的所有成员引用的是内存中的相同位置,也就是说如果你想在不同时刻把不同
	  的东西存储于同一个位置,可以使用联合实现
	2.声明后联合所占的字节数看的是联合成员中最大的那个 

     union{
	  	float f;
		int i;
		int c[3];
	}fi;

	int main(){
		//fi.f = 3.1415;
		printf("%ld\n",sizeof(fi.c));
		printf("%ld\n",sizeof(fi.f));
	    printf("%p\n",&fi.c);
     	printf("%p\n",&fi.f);
		*******************
		* 运行结果:       *         
		* 12              *
		* 4               *  
		* 0x5652fbb86018  *            
    	* 0x5652fbb86018  *
		*******************
	}
   其结果表示,联合体的所有成员的地址都是一样的,也就是说当你改变一个成员的值时,所有
   成员都会改变,当你使用成员f,则这个字就作为浮点值访问,当使用成员i时,这个字被作为
   整型处理。
24 动态内存分配
  malloc,realloc,calloc
  1.malloc与calloc的区别
   1)calloc在返回内存的指针之前把它初始化为0
   2)使用calloc时需要包括参数(所需的元素数量和每个元素的字节数)
  2.realloc:用于修改一个原先已经分配的内存块大小
   1)如果用于扩大,则原先的内存块的内容依然保留,新增的内存添加到原先的内存块的后面,注意:新内存并未进行初始化
   2)如果用于缩小,则内存块尾部的b部分内存将会被拿掉,保留剩余部分
   3)如果原先的内存块无法改变大小,realloc将分配另一块正确大小的内存,并把原先的那块内存的内容复制到新的块上,所以使用realloc后,你不能再使用指向旧内存的指针,而是应该改用realloc所返回的新指针
		int *pi;
		//pi = malloc(100); 不推荐使用
		pi = malloc(25 * sizeof(int));//可移植性更高
	   /*
	   **为指针分配了内存(合法化了,自己可以使用,而不是指向不明确的地方)
	   */
	   
	// 下面对该指针进行使用
	   int *q,i;
	   q = pi;
	   for (i = 0; i < 25; ++i) {
			   *q++ = 0;
	   }
	   //也可以是这样
	  for (i = 0; i < 25; ++i) {
	  		q[i] = 0;
	  }
上述例子我们拥有了指向100个字节的指针,这块内存也可以被当作25个整型元素的数组,因为pi是指向整型的指针
  常见的动态内存错误
   0)忘记检查所请求的内存是否成功分配
   1)对NULL指针进行解引用操作
   2)对分配的内存进行操作是越界
   3)释放了并非动态分配的内存
   4)试图释放一块动态分配的内存的一部分
   5)使用了被释放后的动态内存
  最常见的就是(0)的错误了
  解决办法分配完内存后利用if来判断如下:
  		if(pi == NULL)
			printf("Can't get memory for that many values");
			exit(EXIT_FAILURE);
  还有就是使用free时:
  	传递给free的指针必须是一个从calloc,malloc,realloc函数返回的指针
	释放一块内存的一部分是不允许的.动态分配的内存必须整块一起释放,如果一定要
	释放一部分,使用realloc函数可以有效的释放尾部的部分内存
  下面是内存动态分配的实例:
   1.
	 /*
	 ** 该函数由qsort调用，用于比较整型值
	 */
int compare_intergers(void const *a,void const *b){
	 register int const *pa = a;
	 register int const *pb = b;
	 return *pa > *pb ? 1 : *pa < *pb ? -1 :0;
	 /*
	   return里的东西等价于
		if (*pa > *pb) {
			return 1;
			else{
				if(*pa < *pb){
					return -1;
				}
			      else{
				  return 0;
				  }
			}		
		} 
      很明显当判断的条件比较冗长时使用第一种方式更为合适
	 */
}

int main(int argc, char *argv[])
{
		int *array;
		int n_values;
		int i;
     
	 /*
	 **观察共有多少个值
	 */
		printf("How many values are there?\n");
		if (scanf("%d",&n_values) != 1 || n_values <= 0) {
			printf("Illegal number of values.\n");
			exit(EXIT_FAILURE);
		}
 		/*
		** scanf("%d",&n_values) != 1 它的返回值是成功键入的个数
		** 也就是说如果键入失败那么返回值就是0,成功键入2个数返回的就是2
		*/
		
	 /*
	 **分配内存，用于存储这些值,并且对分配是否成功进行了判断
	 */
  	  	array = malloc(n_values * sizeof(int));
		if (array == NULL) {
			 printf("Can't get memory for that many values.\n");	
			 exit(EXIT_FAILURE);
		}	

	 /*
	 **读取这些值
	 */
		for (i = 0; i < n_values; ++i) {
			if (scanf("%d",array + i) != 1) {
					printf("Error reading value #%d\n",i );
					free(array);
					exit(EXIT_FAILURE);
			}
		}

	 /*
	 **对这些值进行排序
	 */
	  qsort(array,n_values,sizeof(int),compare_intergers);
	  
	 /*
	 **打印这些值
	 */
	  for (i = 0; i < n_values; ++i) {
			  printf("array[i] = %d\n", array[i]);
	  }

	 /*
	 **释放内存并退出
	 */
	  free(array);
		return 0;
}
  2.	

/*
**用动态分配内存制作一个字符串的拷贝.注意:调用程序应该负责检查
**这块内存是否成功分配!
*/

char * strdup(char const *string){
	char *new_string;
	/*
	**请求足够长度的内存,用于存储字符串和它结尾的NULL字节
	*/
	new_string = malloc(strlen(string) +1 );
	/*
	**如果分配成功,就复制字符串
	*/
	if (new_string != NULL) {
		strcpy(new_string,string);	
	}
	return new_string;
}

25.链表(linked list)
    1. 包含数据的独立数据结构(也就是节点)的集合,每个节点通过链或指针连接在一起
       节点是动态分配的
	2. 单链表:
		1)每个节点包含一个指向链表下一节点的指针
		2)链表最后一个节点的指针字段的值为NULL,提示你后面不再有其他的节点
		3)只需要知道链表的起始位置,用指针即可遍历整个链表
		  通常使用一个根指针让它指向链表的第一个位置
		  Note:该指针只是一个指针不含其他数据
    	如下就用结构创建了节点
	 typedef struct NODE{
	 	struct NODE *link;
		int   value;
	 }Node;
  
